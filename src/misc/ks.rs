/// Univariate one-sample [Kolmogorov-Smirnov](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test)
/// test.
///
/// Given a set of samples, `xs`, and a distribution `F`, the KS test
/// determines whether `xs` were generated by `F`.
///
/// # Example
///
/// ```rust
/// # extern crate rv;
/// extern crate rand;
///
/// use rv::prelude::*;
/// use rv::misc::ks_test;
///
/// let gauss = Gaussian::standard();
/// let laplace = Laplace::new(0.0, 1.0).unwrap();
///
/// let gauss_cdf = |x: f64| gauss.cdf(&x);
/// let laplace_cdf = |x: f64| laplace.cdf(&x);
///
/// // Generate some samples from the Gaussian
/// let mut rng = rand::thread_rng();
/// let xs = gauss.sample(1000, &mut rng);
///
/// // Check the the samples came from the one that generated them
/// let (_, p_gauss) = ks_test(&xs, gauss_cdf);
/// assert!(p_gauss > 0.05);
///
/// // They did not come from a Laplace
/// let (_, p_laplace) = ks_test(&xs, laplace_cdf);
/// assert!(p_laplace < 0.05);
/// ```
pub fn ks_test<X, F>(xs: &[X], cdf: F) -> (f64, f64)
where
    X: Copy + PartialOrd,
    F: Fn(X) -> f64,
{
    let mut xs_r: Vec<X> = xs.to_vec();
    xs_r.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());

    let n: f64 = xs_r.len() as f64;
    let d = xs_r.iter().enumerate().fold(0.0, |acc, (i, &x)| {
        let diff = ((i as f64) / n - cdf(x)).abs();
        if diff > acc {
            diff
        } else {
            acc
        }
    });

    let p = 1.0 - ks_cdf(xs.len(), d);
    (d, p)
}

pub fn ks_two<X>(xs: &[X], ys: &[X]) -> (f64, f64)
where
    X: Copy + PartialOrd + std::fmt::Debug
{
    let mut xs: Vec<X> = xs.to_vec();
    let mut ys: Vec<X> = ys.to_vec();
    xs.sort_by(|a, b| a.partial_cmp(b).unwrap());
    ys.sort_by(|a, b| a.partial_cmp(b).unwrap());

    let n_x = xs.len();
    let n_y = ys.len();

    let mut it_xs = xs.iter();
    let mut it_ys = ys.iter();

    let mut fn_x = 0.0;
    let mut fn_y = 0.0;

    let d_fn_x = 1.0 / (n_x as f64);
    let d_fn_y = 1.0 / (n_y as f64);

    let mut x_opt = it_xs.next();
    let mut y_opt = it_ys.next();
    let mut d: f64 = 0.0;

    loop {
        match (x_opt, y_opt) {
            (Some(x), Some(y)) => {
                if x < y {
                    fn_x += d_fn_x;
                    x_opt = it_xs.next();
                } else {
                    fn_y += d_fn_y;
                    y_opt = it_ys.next();
                }
                d = d.max((fn_x - fn_y).abs());
            },
            (Some(_), None) => {
                d = d.max(1.0 - fn_x);
                break;
            },
            (None, Some(_)) => {
                d = d.max(1.0 - fn_y);
                break;
            },
            (None, None) => break,
        }
    }
    let n_x_f = n_x as f64;
    let n_y_f = n_y as f64;
    let p = 1.0 - ks_cdf(n_x.min(n_y), d);

    (d, p)
}

fn mmul(xs: &[Vec<f64>], ys: &[Vec<f64>]) -> Vec<Vec<f64>> {
    let m = xs.len();
    let mut zs = vec![vec![0.0; m]; m];
    for i in 0..m {
        for j in 0..m {
            zs[i][j] = (0..m).fold(0.0, |acc, k| acc + xs[i][k] * ys[k][j])
        }
    }
    zs
}

fn mpow(xs: &[Vec<f64>], ea: i32, n: usize) -> (Vec<Vec<f64>>, i32) {
    let m = xs.len();
    if n == 1 {
        (xs.to_owned(), ea)
    } else {
        let (mut zs, mut ev) = mpow(xs, ea, n / 2);
        let ys = mmul(&zs, &zs);
        let eb = 2 * ev;
        if n % 2 == 0 {
            zs = ys;
            ev = eb;
        } else {
            zs = mmul(&xs, &ys);
            ev = ea + eb;
        }
        if zs[m / 2][m / 2] > 1E140 {
            zs.iter_mut().for_each(|zs_i| {
                zs_i.iter_mut().for_each(|z| (*z) *= 1E-140);
            });
            ev += 140;
        }
        (zs, ev)
    }
}

// XXX: ks_cdf, mmul, and mpow are directlt translated from the c program in
// Wang, J., Tsang, W. W., & Marsaglia, G. (2003). Evaluating Kolmogorov's
//     distribution. Journal of Statistical Software, 8(18).
// They are not rusty. Please feel free to make them rusty ðŸ˜˜
fn ks_cdf(n: usize, d: f64) -> f64 {
    let nf = n as f64;
    let s: f64 = d * d * nf;
    if s > 7.24 || (s > 3.76 && n > 99) {
        1.0 - 2.0 * (-(2.000_071 + 0.331 / nf.sqrt() + 1.409 / nf) * s).exp()
    } else {
        let k: usize = ((nf * d) as usize) + 1;
        let m: usize = 2 * k - 1;
        let h: f64 = (k as f64) - nf * d;

        let mut hs = vec![vec![0.0; m]; m];
        for i in 0..m {
            for j in 0..m {
                if ((i as i32) - (j as i32) + 1) >= 0 {
                    hs[i][j] = 1.0
                }
            }
        }

        for i in 0..m {
            hs[i][0] -= h.powi((i as i32) + 1);
            hs[m - 1][i] -= h.powi((m as i32) - (i as i32))
        }

        hs[m - 1][0] += if 2.0 * h - 1.0 > 0.0 {
            (2.0 * h - 1.0).powi(m as i32)
        } else {
            0.0
        };

        for i in 0..m {
            for j in 0..m {
                if (i as i32) - (j as i32) + 1 > 0 {
                    for g in 1..=i - j + 1 {
                        hs[i][j] /= g as f64;
                    }
                }
            }
        }

        let (qs, mut eq) = mpow(&hs, 0, n);
        let mut s = qs[k - 1][k - 1];
        for i in 1..n {
            s *= (i as f64) / nf;
            if s < 1e-140 {
                s *= 1e140;
                eq -= 140;
            }
        }
        s * 10.0_f64.powi(eq)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dist::Gaussian;
    use crate::traits::Cdf;

    const TOL: f64 = 1E-12;

    #[test]
    fn ks_cdf_normal() {
        assert::close(ks_cdf(10, 0.274), 0.6284796154565043, TOL);
    }

    #[test]
    fn ks_cdf_large_n() {
        assert::close(ks_cdf(1000, 0.074), 0.9999671735299037, TOL);
    }

    #[test]
    fn ks_test_pval() {
        let xs: Vec<f64> =
            vec![0.42, 0.24, 0.86, 0.85, 0.82, 0.82, 0.25, 0.78, 0.13, 0.27];

        let g = Gaussian::standard();
        let cdf = |x: f64| g.cdf(&x);
        let (ks, p) = ks_test(&xs, cdf);

        assert::close(ks, 0.55171678665456114, TOL);
        assert::close(p, 0.0021804502526949765, TOL);
    }

    #[test]
    fn ks_two_known() {
        let xs: Vec<f64> = vec![
            1.62805595, -1.28284995, -0.16074287,  0.36135322,  0.01440087,
            -1.0059501 ,  1.53957475, -1.04123753, -0.41885811,  0.54975795,
            -0.47733008,  1.10397893, -0.84994073, -0.20375695, -0.12977272,
            0.915276  ,  0.71426726, -1.54661317,  0.38228231,  0.26592397
        ];

        let ys: Vec<f64> = vec![
            0.39391058, -0.39739767,  1.67236872,  1.16190065, -1.93320129,
            -0.11767175,  1.01881742,  0.26254619,  1.15808479, -0.47545073,
            -2.47376934, -1.6341644 , -0.40558285,  0.75866004, -1.86267948,
            0.22708557, -1.11218436,  0.68928247, -1.08577561, -1.95370744
        ];

        let (stat, p) = ks_two(&xs, &ys);
        assert::close(stat, 0.25, TOL);
        assert::close(p, 0.4973423353136131, TOL);
    }
}
